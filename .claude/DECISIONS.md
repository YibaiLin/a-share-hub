# A-Share Hub - 技术决策记录

> ADR (Architecture Decision Records) - 记录项目中的重要技术决策

## 📋 决策索引

| 编号 | 标题 | 日期 | 状态 |
|------|------|------|------|
| ADR-001 | 选择ClickHouse作为主存储 | 2025-10-12 | ✅ 已采纳 |
| ADR-002 | 价格数据×100存储为整型 | 2025-10-12 | ✅ 已采纳 |
| ADR-003 | 使用APScheduler而非Celery | 2025-10-12 | ✅ 已采纳 |
| ADR-004 | 空值使用-1而非NULL | 2025-10-12 | ✅ 已采纳 |
| ADR-005 | 使用pydantic-settings管理配置 | 2025-10-12 | ✅ 已采纳 |
| ADR-006 | 项目命名为a-share-hub | 2025-10-12 | ✅ 已采纳 |
| ADR-007 | 使用prompts目录管理长提示词 | 2025-10-12 | ✅ 已采纳 |
| ADR-008 | GitHub作为远程仓库和协作平台 | 2025-10-12 | ✅ 已采纳 |

---

## ADR-001: 选择ClickHouse作为主存储

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
需要选择一个数据库存储海量时序数据（日线、分钟线、tick数据）。数据特点：
- 写入密集（每天数百万条数据）
- 查询频繁（统计分析、回测）
- 数据不可变（历史数据基本不修改）

### 考虑方案

**方案A: MySQL**
- 优点：成熟稳定，团队熟悉
- 缺点：写入性能有限，存储成本高，不适合时序数据

**方案B: PostgreSQL + TimescaleDB**
- 优点：PostgreSQL生态完善，TimescaleDB专为时序设计
- 缺点：复杂度高，需要额外扩展

**方案C: ClickHouse** ⭐
- 优点：列式存储压缩率高，查询性能优秀，适合时序数据
- 缺点：不支持事务，更新操作慢

**方案D: InfluxDB**
- 优点：专业时序数据库
- 缺点：SQL支持有限，生态不如ClickHouse

### 决策
选择 **ClickHouse**

### 理由
- ✅ 列式存储，压缩率高（10:1以上），节省存储成本
- ✅ 查询性能优秀，特别是聚合查询（日线统计、指标计算）
- ✅ 分区功能强大，便于数据管理和清理
- ✅ 社区活跃，文档完善，中文资料丰富
- ✅ 免费开源，无License限制
- ✅ SQL支持完善，学习成本低
- ❌ 不支持事务（可接受：历史数据只追加，无需事务）
- ❌ 更新操作慢（可接受：使用ReplacingMergeTree处理去重）

### 影响范围
- 涉及模块：storage, scripts
- 破坏性变更：否
- 需要学习：ClickHouse SQL方言

### 后续行动
- [x] 在WSL2中安装ClickHouse
- [x] 设计表结构（分区策略、排序键）
- [ ] Phase 3: 实现连接池
- [ ] Phase 4: 创建数据库表

---

## ADR-002: 价格数据×100存储为整型

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
股票价格是小数（如12.34元），需要决定存储方式。存储方式直接影响：
- 计算精度
- 查询性能
- 存储空间

### 考虑方案

**方案A: Float/Double浮点数**
- 优点：直接存储，使用简单
- 缺点：精度问题（0.1 + 0.2 ≠ 0.3），累计误差

**方案B: Decimal定点数**
- 优点：精度准确
- 缺点：性能较慢，占用空间大

**方案C: Integer整型（×100）** ⭐
- 优点：精度准确，性能快，空间小
- 缺点：需要转换

### 决策
使用 **Integer（×100）**

### 理由
- ✅ 避免浮点数精度问题，计算结果准确
- ✅ 整型运算更快（CPU友好）
- ✅ 存储空间更小（Int32 vs Decimal(10,2)）
- ✅ ClickHouse对整型优化更好（压缩和查询）
- ✅ 精度足够（0.01元，A股最小价格变动单位）
- ❌ 需要显式转换（可接受：统一封装工具函数）

### 实现方案
```python
# 存储时
def price_to_int(price: float | None) -> int:
    return int(price * 100) if price is not None else -1

# 读取时
def int_to_price(value: int) -> float | None:
    return value / 100 if value != -1 else None
```

### 影响范围
- 涉及模块：utils, collectors, storage, api
- 破坏性变更：否
- 数据库设计：所有价格字段使用Int32

### 后续行动
- [ ] Phase 5: 实现price_to_int和int_to_price工具函数
- [ ] Phase 6: 在采集器中应用转换
- [ ] Phase 7: API返回时自动还原

---

## ADR-003: 使用APScheduler而非Celery

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
需要任务调度系统执行定时采集任务（日线、分钟线）。

### 考虑方案

**方案A: APScheduler** ⭐
- 优点：轻量级，易部署，Python原生
- 缺点：不支持分布式

**方案B: Celery**
- 优点：分布式任务队列，功能强大
- 缺点：需要消息队列（Redis/RabbitMQ），部署复杂

**方案C: Airflow**
- 优点：工作流引擎，可视化界面
- 缺点：过于重量级，杀鸡用牛刀

**方案D: Cron**
- 优点：系统级，稳定
- 缺点：Python集成不便，灵活性差

### 决策
选择 **APScheduler**

### 理由
- ✅ 轻量级，易于部署和维护
- ✅ 满足当前需求（单机足够，数据量不大）
- ✅ Python原生，集成简单，无需额外服务
- ✅ 学习成本低，文档完善
- ✅ 支持多种触发器（Cron、Interval、Date）
- ✅ 支持任务持久化（可选，使用Redis）
- ❌ 不支持分布式（可接受：后续可升级）
- ❌ 任务监控较弱（可自行实现日志）

### 后续升级路径
如果需要分布式：
1. APScheduler + Redis Jobstore（中等规模）
2. 迁移到Celery（大规模）
3. 使用Kubernetes CronJob（云原生）

### 影响范围
- 涉及模块：schedulers
- 破坏性变更：否
- 依赖：apscheduler>=3.10.0

### 后续行动
- [ ] Phase 8: 配置APScheduler
- [ ] Phase 8: 定义日线和分钟线采集任务

---

## ADR-004: 空值使用-1而非NULL

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
数据中存在空值（如停牌日无数据），需要选择表示方式。

### 考虑方案

**方案A: NULL** 
- 优点：SQL标准，语义清晰
- 缺点：ClickHouse处理NULL有性能损耗

**方案B: -1（Magic Number）** ⭐
- 优点：性能好，查询简单
- 缺点：需要文档说明

**方案C: 0**
- 优点：简单
- 缺点：0可能是合法值（如涨跌幅为0）

### 决策
使用 **-1**

### 理由
- ✅ ClickHouse的NULL处理有性能损耗（需要额外位存储）
- ✅ -1作为magic number语义清晰（价格/涨跌幅不可能为负）
- ✅ 查询时更容易过滤：`WHERE close != -1`
- ✅ 聚合时可以排除：`AVG(IF(close != -1, close, NULL))`
- ❌ 需要文档说明（已在CLAUDE.md中明确）

### 注意事项
- API返回时必须将-1转换为null（用户友好）
- 数据验证时要区分-1（空值）和其他负值（异常）
- 文档中明确说明-1的含义

### 影响范围
- 涉及模块：utils, collectors, storage, api
- 破坏性变更：否
- 数据库设计：不使用Nullable类型

### 后续行动
- [ ] Phase 5: 在数据转换工具中实现空值处理
- [ ] Phase 6: 采集器应用空值转换
- [ ] Phase 7: API返回时转换为null

---

## ADR-005: 使用pydantic-settings管理配置

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
需要管理数据库连接、API密钥等配置信息。

### 考虑方案

**方案A: python-decouple**
- 优点：简单轻量
- 缺点：无类型验证

**方案B: pydantic-settings** ⭐
- 优点：类型验证，IDE支持好
- 缺点：需要学习pydantic

**方案C: dynaconf**
- 优点：多环境配置管理
- 缺点：功能过多，用不上

**方案D: configparser**
- 优点：Python内置
- 缺点：功能弱，无类型验证

### 决策
使用 **pydantic-settings**

### 理由
- ✅ 自动类型验证（端口范围、必填项等）
- ✅ IDE支持好（自动补全、类型检查）
- ✅ 支持嵌套配置（database.host）
- ✅ 支持环境变量覆盖（生产/开发切换方便）
- ✅ 与项目已使用的Pydantic一致（数据模型、API）
- ✅ 配置即文档（类型注解即说明）

### 实现示例
```python
class Settings(BaseSettings):
    debug: bool = False
    port: int = 8000  # 自动验证类型
    
    database: DatabaseConfig  # 嵌套配置
    
    class Config:
        env_file = ".env"
        env_nested_delimiter = "__"  # DATABASE__HOST=xxx

settings = Settings()
```

### 影响范围
- 涉及模块：config
- 破坏性变更：否
- 依赖：pydantic-settings>=2.1.0

### 后续行动
- [ ] Phase 2: 实现Settings配置类
- [ ] Phase 2: 添加配置验证

---

## ADR-006: 项目命名为a-share-hub

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
需要确定项目名称，要求：
- 明确表达"中国A股数据采集"
- 简洁易记
- 适合GitHub仓库名

### 考虑方案
- **a-share-hub** ⭐: 简洁，hub表示数据中心
- **cn-stock-collector**: 完整但较长
- **china-stock-hub**: 对英语用户友好但较长
- **a-share-data-collector**: 最直白但太长

### 决策
使用 **a-share-hub**

### 理由
- ✅ 简洁易记（13个字符）
- ✅ a-share明确指A股
- ✅ hub保留了数据中心的概念（可扩展）
- ✅ 适合GitHub仓库名（简短、清晰）
- ✅ 符合未来扩展需求（不只是collector）

### 影响范围
- GitHub仓库：https://github.com/YibaiLin/a-share-hub
- 项目目录：`a-share-hub/`
- Python包名：可以用 `ashare_hub`（下划线）

---

## ADR-007: 使用prompts目录管理长提示词

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
开发过程中需要使用大量结构化的提示词，直接在命令行输入不方便管理和复用。

### 决策
创建 `prompts/` 目录，按功能分类管理提示词模板。

### 目录结构
```
prompts/
├── init/           # 项目初始化
├── features/       # 功能开发
├── testing/        # 测试相关
└── maintenance/    # 维护优化
```

### 理由
- ✅ 提示词可复用（不同Phase类似的操作）
- ✅ 版本可追踪（Git管理）
- ✅ 结构化组织（易于查找）
- ✅ 便于分享和协作
- ✅ 支持复杂的多步骤提示词

### 使用方式
```bash
# 方式1：引用文件
"请按照 prompts/phase-1-init.md 的要求实现代码"

# 方式2：复制内容
复制prompts文件内容，粘贴到对话框
```

### 影响范围
- 涉及模块：项目根目录
- 破坏性变更：否

---

## ADR-008: GitHub作为远程仓库和协作平台

**日期**: 2025-10-12  
**状态**: ✅ 已采纳  
**决策者**: 项目团队

### 背景
需要选择代码托管平台，要求：
- 版本控制
- 协作功能
- CI/CD支持

### 考虑方案
- **GitHub** ⭐: 最流行，生态完善
- **GitLab**: 功能更多，自托管
- **Gitee**: 国内访问快

### 决策
使用 **GitHub**

### 理由
- ✅ 最流行的代码托管平台
- ✅ 生态完善（Actions, Pages, Packages）
- ✅ 社区活跃，便于开源
- ✅ 免费私有仓库
- ✅ Claude Code有GitHub MCP支持

### 工作流
- 每个Phase完成后推送到GitHub
- 使用GitHub Releases管理版本
- 使用GitHub Issues跟踪问题
- 未来可用GitHub Actions做CI/CD

### 影响范围
- 涉及模块：版本管理
- 仓库：https://github.com/YibaiLin/a-share-hub
- 破坏性变更：否

### 后续行动
- [x] Phase 0: 创建GitHub仓库
- [x] Phase 0: 配置远程仓库
- [ ] Phase 1-8: 每次完成后推送

---

## 📝 决策模板

当需要记录新的技术决策时，使用以下模板：

```markdown
## ADR-XXX: [决策标题]

**日期**: YYYY-MM-DD  
**状态**: 🤔 提议中 / ✅ 已采纳 / ❌ 已拒绝  
**决策者**: [姓名/团队]

### 背景
[为什么需要做这个决策？遇到什么问题？]

### 考虑方案

**方案A: [名称]**
- 优点: 
- 缺点: 

**方案B: [名称]** ⭐
- 优点: 
- 缺点: 

### 决策
选择 **方案X**

### 理由
- ✅ [原因1]
- ✅ [原因2]
- ❌ [可接受的权衡]

### 影响范围
- 涉及模块: [列表]
- 破坏性变更: 是/否
- 需要迁移: 是/否

### 后续行动
- [ ] [待办事项1]
- [ ] [待办事项2]
```

---

## 🔍 决策原则

### 技术选型原则
1. **简单优先**：选择最简单能满足需求的方案
2. **性能考虑**：关键路径（数据采集、存储、查询）优先考虑性能
3. **可维护性**：代码要易于理解和维护
4. **可扩展性**：为未来增长留有空间
5. **成本控制**：优先使用免费开源方案

### 决策流程
1. **识别问题**：明确需要决策的问题
2. **列举方案**：至少考虑2-3个方案
3. **分析权衡**：列出每个方案的优缺点
4. **做出选择**：基于项目需求选择最合适的
5. **记录决策**：使用ADR记录，说明理由
6. **执行实施**：在TODO.md中添加相关任务

### 决策评审
- 重大决策（影响架构）：讨论后记录
- 中等决策（技术选型）：快速决策，记录
- 小决策（实现细节）：不需要记录ADR

---

## 📚 参考资源

- [ADR最佳实践](https://adr.github.io/)
- [技术决策记录模板](https://github.com/joelparkerhenderson/architecture-decision-record)

---

**最后更新**: 2025-10-12